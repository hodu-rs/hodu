//! C code generation for CPU kernel execution
//!
//! Generates C source code that calls hodu_cpu_kernels functions.

use crate::dispatch::{DispatchManifest, KernelDispatch};

/// Generate C code from dispatch manifest
pub fn generate_c_code(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    // Header with kernel declarations
    code.push_str(&generate_header(manifest));

    // Buffer allocation struct
    code.push_str(&generate_buffer_struct(manifest));

    // Constant data
    code.push_str(&generate_constants(manifest));

    // Init function
    code.push_str(&generate_init_function(manifest));

    // Execute function
    code.push_str(&generate_execute_function(manifest));

    // Cleanup function
    code.push_str(&generate_cleanup_function(manifest));

    code
}

fn generate_header(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    code.push_str("// Auto-generated by hodu-compiler-cpu\n");
    code.push_str("// Do not edit manually\n\n");
    code.push_str("#include <stddef.h>\n");
    code.push_str("#include <stdint.h>\n");
    code.push_str("#include <stdlib.h>\n");
    code.push_str("#include <string.h>\n\n");

    // Collect unique kernel declarations
    let mut seen_kernels = std::collections::HashSet::new();

    code.push_str("// Kernel function declarations\n");
    for dispatch in &manifest.dispatches {
        // Skip noop operations
        if dispatch.op_type == "dummy" || dispatch.op_type == "shape" {
            continue;
        }

        // Skip if already declared
        if seen_kernels.contains(&dispatch.kernel_name) {
            continue;
        }
        seen_kernels.insert(dispatch.kernel_name.clone());

        // Generate extern declaration based on op_type
        let decl = generate_kernel_declaration(&dispatch.kernel_name, &dispatch.op_type);
        code.push_str(&decl);
    }

    code.push_str("\n");
    code
}

fn generate_kernel_declaration(kernel_name: &str, op_type: &str) -> String {
    match op_type {
        // Binary ops: (lhs, rhs, output, metadata)
        "binary" | "binary_logical" | "cmp" => {
            format!(
                "extern void {}(const void *lhs, const void *rhs, void *output, const size_t *metadata);\n",
                kernel_name
            )
        },

        // Unary ops: (input, output, metadata)
        "unary" | "unary_logical" | "reduce" | "windowing" | "concat" | "split" | "memory" => {
            format!(
                "extern void {}(const void *input, void *output, const size_t *metadata);\n",
                kernel_name
            )
        },

        // Unary with scalar: (input, output, metadata, scalar)
        "unary_scalar" | "cmp_scalar" => {
            format!(
                "extern void {}(const void *input, void *output, const size_t *metadata, const void *scalar);\n",
                kernel_name
            )
        },

        // Matrix ops: (lhs, rhs, output, metadata)
        "matrix" => {
            format!(
                "extern void {}(const void *lhs, const void *rhs, void *output, const size_t *metadata);\n",
                kernel_name
            )
        },

        // Conv ops: (input, weight, output, metadata)
        "conv" => {
            format!(
                "extern void {}(const void *input, const void *weight, void *output, const size_t *metadata);\n",
                kernel_name
            )
        },

        // Cast ops: (input, output, metadata)
        "cast" => {
            format!(
                "extern void {}(const void *input, void *output, const size_t *metadata);\n",
                kernel_name
            )
        },

        // Indexing ops - varying signatures
        "indexing" => {
            // Determine specific indexing operation from kernel name
            if kernel_name.contains("index_select") {
                format!(
                    "extern void {}(const void *input, const int32_t *indices, void *output, const size_t *metadata);\n",
                    kernel_name
                )
            } else if kernel_name.contains("index_put") {
                format!(
                    "extern void {}(const void *input, const int32_t *indices, const void *values, void *output, const size_t *metadata);\n",
                    kernel_name
                )
            } else if kernel_name.contains("gather") {
                format!(
                    "extern void {}(const void *input, const int32_t *indices, void *output, const size_t *metadata);\n",
                    kernel_name
                )
            } else if kernel_name.contains("scatter") {
                // scatter, scatter_add, scatter_max, scatter_min
                format!(
                    "extern void {}(const void *input, const int32_t *indices, const void *src, void *output, const size_t *metadata);\n",
                    kernel_name
                )
            } else {
                format!("// TODO: unknown indexing op: {}\n", kernel_name)
            }
        },

        _ => {
            format!("// TODO: unknown op_type '{}' for kernel: {}\n", op_type, kernel_name)
        },
    }
}

fn generate_buffer_struct(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    code.push_str("// Buffer management\n");
    code.push_str("typedef struct {\n");
    code.push_str(&format!("    void* buffers[{}];\n", manifest.num_buffers));
    code.push_str(&format!("    size_t sizes[{}];\n", manifest.num_buffers));
    code.push_str("    int initialized;\n");
    code.push_str("} HoduBuffers;\n\n");

    code.push_str("static HoduBuffers g_buffers = {0};\n\n");

    code
}

fn generate_constants(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    code.push_str("// Constant data\n");
    for constant in &manifest.constants {
        code.push_str(&format!(
            "static const unsigned char constant_{}[] = {{\n    ",
            constant.buffer_id
        ));

        // Output bytes in hex format, 16 per line
        for (i, byte) in constant.data.iter().enumerate() {
            if i > 0 && i % 16 == 0 {
                code.push_str("\n    ");
            }
            code.push_str(&format!("0x{:02x}, ", byte));
        }

        code.push_str("\n};\n\n");
    }

    code
}

fn generate_init_function(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    code.push_str("// Initialize buffers\n");
    code.push_str("int hodu_init(void) {\n");
    code.push_str("    if (g_buffers.initialized) return 0;\n\n");

    // Allocate buffers for constants and copy data
    for constant in &manifest.constants {
        code.push_str(&format!(
            "    g_buffers.buffers[{}] = malloc({});\n",
            constant.buffer_id, constant.size_bytes
        ));
        code.push_str(&format!(
            "    if (!g_buffers.buffers[{}]) return -1;\n",
            constant.buffer_id
        ));
        code.push_str(&format!(
            "    memcpy(g_buffers.buffers[{}], constant_{}, {});\n",
            constant.buffer_id, constant.buffer_id, constant.size_bytes
        ));
        code.push_str(&format!(
            "    g_buffers.sizes[{}] = {};\n\n",
            constant.buffer_id, constant.size_bytes
        ));
    }

    code.push_str("    g_buffers.initialized = 1;\n");
    code.push_str("    return 0;\n");
    code.push_str("}\n\n");

    code
}

fn generate_execute_function(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    // Generate function signature
    code.push_str("// Execute the compiled graph\n");
    code.push_str("int hodu_execute(\n");

    // Input parameters
    for (i, input) in manifest.inputs.iter().enumerate() {
        code.push_str(&format!("    const void* input_{}", i));
        if i < manifest.inputs.len() - 1 || !manifest.outputs.is_empty() {
            code.push_str(",\n");
        }
    }

    // Output parameters
    for (i, output) in manifest.outputs.iter().enumerate() {
        code.push_str(&format!("    void* output_{}", i));
        if i < manifest.outputs.len() - 1 {
            code.push_str(",\n");
        }
    }

    code.push_str("\n) {\n");

    // Bind inputs to buffers
    code.push_str("    // Bind inputs\n");
    for (i, input) in manifest.inputs.iter().enumerate() {
        code.push_str(&format!(
            "    g_buffers.buffers[{}] = (void*)input_{};\n",
            input.buffer_id, i
        ));
    }
    code.push_str("\n");

    // Allocate intermediate buffers
    code.push_str("    // Allocate intermediate buffers\n");
    let mut intermediate_buffers = Vec::new();
    for dispatch in &manifest.dispatches {
        // Check if output buffer needs allocation (not an input or constant)
        let is_input = manifest.inputs.iter().any(|i| i.buffer_id == dispatch.output_buffer);
        let is_constant = manifest.constants.iter().any(|c| c.buffer_id == dispatch.output_buffer);
        let is_final_output = manifest.outputs.iter().any(|o| o.buffer_id == dispatch.output_buffer);

        if !is_input && !is_constant && !is_final_output {
            if !intermediate_buffers.contains(&dispatch.output_buffer) {
                let size_bytes = dispatch.output_size * dtype_size(&dispatch.output_dtype);
                code.push_str(&format!(
                    "    g_buffers.buffers[{}] = malloc({});\n",
                    dispatch.output_buffer, size_bytes
                ));
                code.push_str(&format!(
                    "    if (!g_buffers.buffers[{}]) return -1;\n",
                    dispatch.output_buffer
                ));
                intermediate_buffers.push(dispatch.output_buffer);
            }
        }
    }
    code.push_str("\n");

    // Generate kernel dispatches
    code.push_str("    // Execute kernels\n");
    for (i, dispatch) in manifest.dispatches.iter().enumerate() {
        code.push_str(&generate_kernel_call(dispatch, i, manifest));
    }

    // Bind outputs
    code.push_str("    // Copy outputs\n");
    for (i, output) in manifest.outputs.iter().enumerate() {
        code.push_str(&format!(
            "    memcpy(output_{}, g_buffers.buffers[{}], {});\n",
            i, output.buffer_id, output.size_bytes
        ));
    }
    code.push_str("\n");

    // Free intermediate buffers
    code.push_str("    // Free intermediate buffers\n");
    for buffer_id in &intermediate_buffers {
        code.push_str(&format!("    free(g_buffers.buffers[{}]);\n", buffer_id));
    }

    code.push_str("\n    return 0;\n");
    code.push_str("}\n\n");

    code
}

fn generate_kernel_call(dispatch: &KernelDispatch, index: usize, manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    // Skip dummy/noop operations
    if dispatch.op_type == "dummy" || dispatch.op_type == "shape" {
        code.push_str(&format!("    // [{}] {} (noop)\n", index, dispatch.kernel_name));
        return code;
    }

    code.push_str(&format!("    // [{}] {}\n", index, dispatch.kernel_name));

    // Generate metadata array
    code.push_str(&format!("    static const size_t metadata_{}[] = {{ ", index));
    for (i, m) in dispatch.metadata.iter().enumerate() {
        if i > 0 {
            code.push_str(", ");
        }
        code.push_str(&format!("{}", m));
    }
    code.push_str(" };\n");

    // Check if this is a final output buffer
    let is_final_output = manifest.outputs.iter().any(|o| o.buffer_id == dispatch.output_buffer);

    // Allocate output buffer if it's a final output
    if is_final_output {
        let size_bytes = dispatch.output_size * dtype_size(&dispatch.output_dtype);
        code.push_str(&format!(
            "    g_buffers.buffers[{}] = malloc({});\n",
            dispatch.output_buffer, size_bytes
        ));
    }

    // Generate kernel call based on op type
    match dispatch.op_type.as_str() {
        // Binary ops: (lhs, rhs, output, metadata)
        "binary" | "binary_logical" | "cmp" => {
            code.push_str(&format!(
                "    {}(g_buffers.buffers[{}], g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                dispatch.kernel_name,
                dispatch.input_buffers.get(0).unwrap_or(&0),
                dispatch.input_buffers.get(1).unwrap_or(&0),
                dispatch.output_buffer,
                index
            ));
        },

        // Unary ops: (input, output, metadata)
        "unary" | "unary_logical" | "memory" | "reduce" | "cast" | "concat" | "split" | "windowing" => {
            code.push_str(&format!(
                "    {}(g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                dispatch.kernel_name,
                dispatch.input_buffers.get(0).unwrap_or(&0),
                dispatch.output_buffer,
                index
            ));
        },

        // Unary with scalar: (input, output, metadata, &scalar)
        "unary_scalar" | "cmp_scalar" => {
            let scalar = dispatch.scalars.get(0).unwrap_or(&0.0);
            let c_type = dtype_to_c_type(&dispatch.output_dtype);
            let scalar_val = format_scalar_value(*scalar, &dispatch.output_dtype);
            code.push_str(&format!(
                "    {{ {c_type} scalar_{index} = {scalar_val}; {kernel}(g_buffers.buffers[{in0}], g_buffers.buffers[{out}], metadata_{index}, &scalar_{index}); }}\n",
                c_type = c_type,
                index = index,
                scalar_val = scalar_val,
                kernel = dispatch.kernel_name,
                in0 = dispatch.input_buffers.get(0).unwrap_or(&0),
                out = dispatch.output_buffer,
            ));
        },

        // Matrix ops: (lhs, rhs, output, metadata)
        "matrix" => {
            code.push_str(&format!(
                "    {}(g_buffers.buffers[{}], g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                dispatch.kernel_name,
                dispatch.input_buffers.get(0).unwrap_or(&0),
                dispatch.input_buffers.get(1).unwrap_or(&0),
                dispatch.output_buffer,
                index
            ));
        },

        // Conv ops: (input, weight, output, metadata)
        "conv" => {
            code.push_str(&format!(
                "    {}(g_buffers.buffers[{}], g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                dispatch.kernel_name,
                dispatch.input_buffers.get(0).unwrap_or(&0),
                dispatch.input_buffers.get(1).unwrap_or(&0),
                dispatch.output_buffer,
                index
            ));
        },

        // Indexing ops - varying signatures
        "indexing" => {
            if dispatch.kernel_name.contains("index_select") {
                // index_select: (input, indices, output, metadata)
                code.push_str(&format!(
                    "    {}(g_buffers.buffers[{}], (const int32_t*)g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                    dispatch.kernel_name,
                    dispatch.input_buffers.get(0).unwrap_or(&0),
                    dispatch.input_buffers.get(1).unwrap_or(&0),
                    dispatch.output_buffer,
                    index
                ));
            } else if dispatch.kernel_name.contains("index_put") {
                // index_put: (input, indices, values, output, metadata)
                code.push_str(&format!(
                    "    {}(g_buffers.buffers[{}], (const int32_t*)g_buffers.buffers[{}], g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                    dispatch.kernel_name,
                    dispatch.input_buffers.get(0).unwrap_or(&0),
                    dispatch.input_buffers.get(1).unwrap_or(&0),
                    dispatch.input_buffers.get(2).unwrap_or(&0),
                    dispatch.output_buffer,
                    index
                ));
            } else if dispatch.kernel_name.contains("gather") {
                // gather: (input, indices, output, metadata)
                code.push_str(&format!(
                    "    {}(g_buffers.buffers[{}], (const int32_t*)g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                    dispatch.kernel_name,
                    dispatch.input_buffers.get(0).unwrap_or(&0),
                    dispatch.input_buffers.get(1).unwrap_or(&0),
                    dispatch.output_buffer,
                    index
                ));
            } else if dispatch.kernel_name.contains("scatter") {
                // scatter: (input, indices, src, output, metadata)
                code.push_str(&format!(
                    "    {}(g_buffers.buffers[{}], (const int32_t*)g_buffers.buffers[{}], g_buffers.buffers[{}], g_buffers.buffers[{}], metadata_{});\n",
                    dispatch.kernel_name,
                    dispatch.input_buffers.get(0).unwrap_or(&0),
                    dispatch.input_buffers.get(1).unwrap_or(&0),
                    dispatch.input_buffers.get(2).unwrap_or(&0),
                    dispatch.output_buffer,
                    index
                ));
            } else {
                code.push_str(&format!("    // TODO: unknown indexing op: {}\n", dispatch.kernel_name));
            }
        },

        _ => {
            code.push_str(&format!(
                "    // TODO: implement {} kernel call for {}\n",
                dispatch.op_type, dispatch.kernel_name
            ));
        },
    }

    code.push_str("\n");
    code
}

fn dtype_to_c_type(dtype: &str) -> &'static str {
    match dtype {
        "bool" => "uint8_t",
        "f8e4m3" | "f8e5m2" => "uint8_t",
        "bf16" | "f16" => "uint16_t",
        "f32" => "float",
        "f64" => "double",
        "u8" => "uint8_t",
        "u16" => "uint16_t",
        "u32" => "uint32_t",
        "u64" => "uint64_t",
        "i8" => "int8_t",
        "i16" => "int16_t",
        "i32" => "int32_t",
        "i64" => "int64_t",
        _ => "float",
    }
}

fn format_scalar_value(value: f64, dtype: &str) -> String {
    match dtype {
        "f32" => format!("{}f", value),
        "f64" => format!("{}", value),
        "i8" | "i16" | "i32" => format!("{}", value as i32),
        "i64" => format!("{}LL", value as i64),
        "u8" | "u16" | "u32" => format!("{}U", value as u32),
        "u64" => format!("{}ULL", value as u64),
        "bool" => format!("{}", if value != 0.0 { 1 } else { 0 }),
        // For exotic floats, store as raw bits
        "bf16" | "f16" => format!("0x{:04X}U", (value as f32).to_bits() >> 16),
        "f8e4m3" | "f8e5m2" => format!("0x{:02X}U", (value as f32).to_bits() >> 24),
        _ => format!("{}f", value),
    }
}

fn generate_cleanup_function(manifest: &DispatchManifest) -> String {
    let mut code = String::new();

    code.push_str("// Cleanup resources\n");
    code.push_str("void hodu_cleanup(void) {\n");
    code.push_str("    if (!g_buffers.initialized) return;\n\n");

    // Free constant buffers
    for constant in &manifest.constants {
        code.push_str(&format!(
            "    if (g_buffers.buffers[{}]) free(g_buffers.buffers[{}]);\n",
            constant.buffer_id, constant.buffer_id
        ));
    }

    code.push_str("\n    g_buffers.initialized = 0;\n");
    code.push_str("}\n");

    code
}

fn dtype_size(dtype: &str) -> usize {
    match dtype {
        "bool" => 1,
        "f8e4m3" | "f8e5m2" | "u8" | "i8" => 1,
        "bf16" | "f16" | "u16" | "i16" => 2,
        "f32" | "u32" | "i32" => 4,
        "f64" | "u64" | "i64" => 8,
        _ => 4, // default to f32 size
    }
}
